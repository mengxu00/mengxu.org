P <- P/rowSums(P)
P[is.na(P)] <- 0
# Sub-blocks
Q <- P[1:(n_vertex - n_end), 1:(n_vertex - n_end)]
R <- P[1:nrow(Q), (nrow(Q)+1):nrow(P)]
I <- P[idx_I, idx_I]
O <- P[(nrow(Q)+1):nrow(P), 1:nrow(Q)]
# edge kwalks
mtx_fundamental <- diag(nrow(Q)) - Q
N <- solve(mtx_fundamental)
N[v_start, ]
library(gplots)
heatmap.2(N,dendrogram='none', Rowv=FALSE, Colv=FALSE,trace='none')
# Visualize as size of vertex
V(g1)$size <- max(N[v_start, ])
V(g1)[!(V(g1)$type %in% 'end')]$size <- N[v_start, ]
V(g1)$size <- V(g1)$size * 3
# plot
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l)
# edge passage time
E(g1)
e_lst <- as_edgelist(g1, names=T)
e_passage_time <- apply(e_lst, 1, function(x){
i = as.character(x[1])
j = as.character(x[2])
if(i %in% v_end){
# background level
# return(N[j, j] * P[j, i])
return(0)
}else{
if(j %in% v_end){
# sink
return(N[i, i] * P[i, j])
}else{
# non-sink
return(N[i, j] * P[i, j])
}
}
}
)
E(g1)$width <- unlist(e_passage_time) * 10
#plot
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l)
# kwalks
library(igraph)
install.packages('igraph')
# kwalks
library(igraph)
# Sample network
g1 <- graph_from_literal(1-2-3-4-5-1-3-5-2-4-1,
6-7-8-9-10-6-8-10-7-9-6,
3-6-11-3,
simplify = F)
plot(g1)
V(g1)
g1[]
# Vertex type
v_start <- c(1)
v_end <- c(9)
# kwalks
library(igraph)
# detach(package:igraph)
# Sample network
g1 <- graph_from_literal(1-2-3-4-5-1-3-5-2-4-1,
6-7-8-9-10-6-8-10-7-9-6,
3-6-11-3,
simplify = F)
plot(g1)
V(g1)
g1[]
# Vertex type
v_start <- c(1)
v_end <- c(9)
n_vertex <- length(V(g1))
n_end <- length(v_end)
# Vertex label
V(g1)$type <- sapply(1:length(V(g1)), function(x){
if(x %in% v_start) return('start')
if(x %in% v_end) return('end')
return('v')
})
# Vertex color
V(g1)$color <- sapply(1:length(V(g1)), function(x){
if(x %in% v_start) return('tomato')
if(x %in% v_end) return('skyblue')
return('grey70')
})
vertex_attr(g1)
# plot
layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1]
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l)
# State transition matrix
# subv <- c(1:8, 10:11)
# g2 <- induced.subgraph(graph=g1,vids=subv)
# set.seed(2)
# plot(g2)
# Canonical form
# QR/OI
idx_Q <- V(g1)[!(V(g1) %in% v_end)]
idx_R <- V(g1)[(V(g1) %in% v_end)]
idx_P <- c(idx_Q, idx_R)
idx_I <- which(idx_P %in% idx_R)
# init P
P <- as.matrix(get.adjacency(g1))[idx_P,idx_P]
# init O
P[!(idx_P %in% idx_Q), (idx_P %in% idx_Q)] <- 0
# init I
P[idx_I, idx_I] <- diag(length(idx_R))
# Adjacency to state transition matrix
P <- P/rowSums(P)
P[is.na(P)] <- 0
# Sub-blocks
Q <- P[1:(n_vertex - n_end), 1:(n_vertex - n_end)]
R <- P[1:nrow(Q), (nrow(Q)+1):nrow(P)]
I <- P[idx_I, idx_I]
O <- P[(nrow(Q)+1):nrow(P), 1:nrow(Q)]
# edge kwalks
mtx_fundamental <- diag(nrow(Q)) - Q
N <- solve(mtx_fundamental)
N[v_start, ]
library(gplots)
heatmap.2(N,dendrogram='none', Rowv=FALSE, Colv=FALSE,trace='none')
# Visualize as size of vertex
V(g1)$size <- max(N[v_start, ])
V(g1)[!(V(g1)$type %in% 'end')]$size <- N[v_start, ]
V(g1)$size <- V(g1)$size * 3
# plot
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l)
# edge passage time
E(g1)
e_lst <- as_edgelist(g1, names=T)
e_passage_time <- apply(e_lst, 1, function(x){
i = as.character(x[1])
j = as.character(x[2])
if(i %in% v_end){
# background level
# return(N[j, j] * P[j, i])
return(0)
}else{
if(j %in% v_end){
# sink
return(N[i, i] * P[i, j])
}else{
# non-sink
return(N[i, j] * P[i, j])
}
}
}
)
E(g1)$width <- unlist(e_passage_time) * 10
#plot
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l)
# kwalks
library(igraph)
library(corrplot)
par(mfrow=c(2,2), c(0,0,0,0))
#======================================================================#
# Sample network
#======================================================================#
g1 <- graph_from_literal(1-2-3-4-5-1-3-5-2-4-1,
6-7-8-9-10-6-8-10-7-9-6,
3-6-11-3,
simplify = F)
# Vertex type
v_start <- c(1)
v_end <- c(9)
n_vertex <- length(V(g1))
n_end <- length(v_end)
# Vertex label
V(g1)$type <- sapply(1:length(V(g1)), function(x){
if(x %in% v_start) return('start')
if(x %in% v_end) return('end')
return('v')
})
# Vertex color
V(g1)$color <- sapply(1:length(V(g1)), function(x){
if(x %in% v_start) return('tomato')
if(x %in% v_end) return('skyblue')
return('grey70')
})
vertex_attr(g1)
# plot
layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1]
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Initial network")
#======================================================================#
# State transition matrix
#======================================================================#
# Canonical form
# QR/OI
idx_Q <- V(g1)[!(V(g1) %in% v_end)]
idx_R <- V(g1)[(V(g1) %in% v_end)]
idx_P <- c(idx_Q, idx_R)
idx_I <- which(idx_P %in% idx_R)
# init P
P <- as.matrix(get.adjacency(g1))[idx_P,idx_P]
# init O
P[!(idx_P %in% idx_Q), (idx_P %in% idx_Q)] <- 0
# init I
P[idx_I, idx_I] <- diag(length(idx_R))
# Adjacency to state transition matrix
P <- P/rowSums(P)
P[is.na(P)] <- 0
# Sub-blocks
Q <- P[1:(n_vertex - n_end), 1:(n_vertex - n_end)]
R <- P[1:nrow(Q), (nrow(Q)+1):nrow(P)]
I <- P[idx_I, idx_I]
O <- P[(nrow(Q)+1):nrow(P), 1:nrow(Q)]
#======================================================================#
# Solve fundamental matrix for kwalks
#======================================================================#
mtx_fundamental <- diag(nrow(Q)) - Q
N <- solve(mtx_fundamental)
N[v_start, ]
#  plot P
corrplot((P), method="color", title = 'Matrix P')
# corrplot((N/max(N)), method="color")
# Visualize as size of vertex
V(g1)$size <- max(N[v_start, ])
V(g1)[!(V(g1)$type %in% 'end')]$size <- N[v_start, ]
V(g1)$size <- V(g1)$size * 3
# plot node visited frequency
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Node random walk frequency")
#======================================================================#
# Edge passage time
#======================================================================#
E(g1)
e_lst <- as_edgelist(g1, names=T)
xij_passage_time <- function(x){
i = as.character(x[1])
j = as.character(x[2])
# i = '3'
# j = '6'
if(i %in% v_end){
# background level
# return(N[j, j] * P[j, i])
return(0)
}else{
if(i %in% v_start){
# start step
return(N[i, i] * P[i, j])
}else{
# steps >2
# return(abs(N[1, i] * P[i, j] - N[1, j] * P[j, i])) # non-directed graph only
return(N[v_start, i] * P[i, j])
}
}
}
exij_passage_time <- apply(e_lst, 1, xij_passage_time)
exji_passage_time <- apply(e_lst[, rev(1:ncol(e_lst))], 1, xij_passage_time)
e_passage_time <- abs(exij_passage_time - exji_passage_time)
#======================================================================#
# Plot edge passage time
#======================================================================#
E(g1)$width <- (unlist(e_passage_time) * 10)
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Node & Edge random walk frequency")
library(corrplot)
install.packages('corrplot')
# kwalks
library(igraph)
library(corrplot)
par(mfrow=c(2,2), c(0,0,0,0))
#======================================================================#
# Sample network
#======================================================================#
g1 <- graph_from_literal(1-2-3-4-5-1-3-5-2-4-1,
6-7-8-9-10-6-8-10-7-9-6,
3-6-11-3,
simplify = F)
# Vertex type
v_start <- c(1)
v_end <- c(9)
n_vertex <- length(V(g1))
n_end <- length(v_end)
# Vertex label
V(g1)$type <- sapply(1:length(V(g1)), function(x){
if(x %in% v_start) return('start')
if(x %in% v_end) return('end')
return('v')
})
# Vertex color
V(g1)$color <- sapply(1:length(V(g1)), function(x){
if(x %in% v_start) return('tomato')
if(x %in% v_end) return('skyblue')
return('grey70')
})
vertex_attr(g1)
# plot
layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1]
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Initial network")
#======================================================================#
# State transition matrix
#======================================================================#
# Canonical form
# QR/OI
idx_Q <- V(g1)[!(V(g1) %in% v_end)]
idx_R <- V(g1)[(V(g1) %in% v_end)]
idx_P <- c(idx_Q, idx_R)
idx_I <- which(idx_P %in% idx_R)
# init P
P <- as.matrix(get.adjacency(g1))[idx_P,idx_P]
# init O
P[!(idx_P %in% idx_Q), (idx_P %in% idx_Q)] <- 0
# init I
P[idx_I, idx_I] <- diag(length(idx_R))
# Adjacency to state transition matrix
P <- P/rowSums(P)
P[is.na(P)] <- 0
# Sub-blocks
Q <- P[1:(n_vertex - n_end), 1:(n_vertex - n_end)]
R <- P[1:nrow(Q), (nrow(Q)+1):nrow(P)]
I <- P[idx_I, idx_I]
O <- P[(nrow(Q)+1):nrow(P), 1:nrow(Q)]
#======================================================================#
# Solve fundamental matrix for kwalks
#======================================================================#
mtx_fundamental <- diag(nrow(Q)) - Q
N <- solve(mtx_fundamental)
N[v_start, ]
#  plot P
corrplot((P), method="color", title = 'Matrix P')
# corrplot((N/max(N)), method="color")
# Visualize as size of vertex
V(g1)$size <- max(N[v_start, ])
V(g1)[!(V(g1)$type %in% 'end')]$size <- N[v_start, ]
V(g1)$size <- V(g1)$size * 3
# plot node visited frequency
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Node random walk frequency")
#======================================================================#
# Edge passage time
#======================================================================#
E(g1)
e_lst <- as_edgelist(g1, names=T)
xij_passage_time <- function(x){
i = as.character(x[1])
j = as.character(x[2])
if(i %in% v_end){
# background level
# return(N[j, j] * P[j, i])
return(0)
}else{
if(i %in% v_start){
# start step
return(N[i, i] * P[i, j])
}else{
# steps >2
# return(abs(N[1, i] * P[i, j] - N[1, j] * P[j, i])) # non-directed graph only
return(N[v_start, i] * P[i, j])
}
}
}
exij_passage_time <- apply(e_lst, 1, xij_passage_time)
exji_passage_time <- apply(e_lst[, rev(1:ncol(e_lst))], 1, xij_passage_time)
e_passage_time <- abs(exij_passage_time - exji_passage_time)
#======================================================================#
# Plot edge passage time
#======================================================================#
E(g1)$width <- (unlist(e_passage_time) * 10)
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Node & Edge random walk frequency")
# kwalks
library(igraph)
library(corrplot)
par(mfrow=c(2,2), c(0,0,0,0))
#======================================================================#
# Sample network
#======================================================================#
g1 <- graph_from_literal(1-2-3-4-5-1-3-5-2-4-1,
6-7-8-9-10-6-8-10-7-9-6,
3-6-11-3,
simplify = F)
# Vertex type
v_start <- c(1)
v_end <- c(9)
n_vertex <- length(V(g1))
n_end <- length(v_end)
# Vertex label
V(g1)$type <- sapply(1:length(V(g1)), function(x){
if(x %in% v_start) return('start')
if(x %in% v_end) return('end')
return('v')
})
# Vertex color
V(g1)$color <- sapply(1:length(V(g1)), function(x){
if(x %in% v_start) return('tomato')
if(x %in% v_end) return('skyblue')
return('grey70')
})
vertex_attr(g1)
# plot
layouts <- grep("^layout_", ls("package:igraph"), value=TRUE)[-1]
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Initial network")
#======================================================================#
# State transition matrix
#======================================================================#
# Canonical form
# QR/OI
idx_Q <- V(g1)[!(V(g1) %in% v_end)]
idx_R <- V(g1)[(V(g1) %in% v_end)]
idx_P <- c(idx_Q, idx_R)
idx_I <- which(idx_P %in% idx_R)
# init P
P <- as.matrix(get.adjacency(g1))[idx_P,idx_P]
# init O
P[!(idx_P %in% idx_Q), (idx_P %in% idx_Q)] <- 0
# init I
P[idx_I, idx_I] <- diag(length(idx_R))
# Adjacency to state transition matrix
P <- P/rowSums(P)
P[is.na(P)] <- 0
# Sub-blocks
Q <- P[1:(n_vertex - n_end), 1:(n_vertex - n_end)]
R <- P[1:nrow(Q), (nrow(Q)+1):nrow(P)]
I <- P[idx_I, idx_I]
O <- P[(nrow(Q)+1):nrow(P), 1:nrow(Q)]
#======================================================================#
# Solve fundamental matrix for kwalks
#======================================================================#
mtx_fundamental <- diag(nrow(Q)) - Q
N <- solve(mtx_fundamental)
N[v_start, ]
#  plot P
corrplot((P), method="color", title = 'Matrix P')
# corrplot((N/max(N)), method="color")
# Visualize as size of vertex
V(g1)$size <- max(N[v_start, ])
V(g1)[!(V(g1)$type %in% 'end')]$size <- N[v_start, ]
V(g1)$size <- V(g1)$size * 3
# plot node visited frequency
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Node random walk frequency")
#======================================================================#
# Edge passage time
#======================================================================#
E(g1)
e_lst <- as_edgelist(g1, names=T)
xij_passage_time <- function(x){
i = as.character(x[1])
j = as.character(x[2])
if(i %in% v_end){
# background level
# return(N[j, j] * P[j, i])
return(0)
}else{
if(i %in% v_start){
# start step
return(N[i, i] * P[i, j])
}else{
# steps >2
# return(abs(N[1, i] * P[i, j] - N[1, j] * P[j, i])) # non-directed graph only
return(N[v_start, i] * P[i, j])
}
}
}
exij_passage_time <- apply(e_lst, 1, xij_passage_time)
exji_passage_time <- apply(e_lst[, rev(1:ncol(e_lst))], 1, xij_passage_time)
e_passage_time <- abs(exij_passage_time - exji_passage_time)
#======================================================================#
# Plot edge passage time
#======================================================================#
E(g1)$width <- (unlist(e_passage_time) * 10)
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Node & Edge random walk frequency")
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages("rstudioapi")
install.packages("rstudioapi")
rstudioapi::isAvailable("0.99.149")
devtools::install_github("r-lib/devtools")
library(devtools)
has_devel()
library(roxygen2)
library(testthat)
devtools::session_info()
