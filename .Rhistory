R <- P[1:nrow(Q), (nrow(Q)+1):nrow(P)]
I <- P[idx_I, idx_I]
O <- P[(nrow(Q)+1):nrow(P), 1:nrow(Q)]
#======================================================================#
# Solve fundamental matrix for kwalks
#======================================================================#
mtx_fundamental <- diag(nrow(Q)) - Q
N <- solve(mtx_fundamental)
N[v_start, ]
#  plot P
corrplot((P), method="color", title = 'Matrix P')
# corrplot((N/max(N)), method="color")
# Visualize as size of vertex
V(g1)$size <- max(N[v_start, ])
V(g1)[!(V(g1)$type %in% 'end')]$size <- N[v_start, ]
V(g1)$size <- V(g1)$size * 3
# plot node visited frequency
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Node random walk frequency")
#======================================================================#
# Edge passage time
#======================================================================#
E(g1)
e_lst <- as_edgelist(g1, names=T)
xij_passage_time <- function(x){
i = as.character(x[1])
j = as.character(x[2])
if(i %in% v_end){
# background level
# return(N[j, j] * P[j, i])
return(0)
}else{
if(i %in% v_start){
# start step
return(N[i, i] * P[i, j])
}else{
# steps >2
# return(abs(N[1, i] * P[i, j] - N[1, j] * P[j, i])) # non-directed graph only
return(N[v_start, i] * P[i, j])
}
}
}
exij_passage_time <- apply(e_lst, 1, xij_passage_time)
exji_passage_time <- apply(e_lst[, rev(1:ncol(e_lst))], 1, xij_passage_time)
e_passage_time <- abs(exij_passage_time - exji_passage_time)
#======================================================================#
# Plot edge passage time
#======================================================================#
E(g1)$width <- (unlist(e_passage_time) * 10)
set.seed(2)
l <- layout_with_gem(g1)
plot(g1, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5,
layout=l, main = "Node & Edge random walk frequency")
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages("rstudioapi")
install.packages("rstudioapi")
rstudioapi::isAvailable("0.99.149")
devtools::install_github("r-lib/devtools")
library(devtools)
has_devel()
library(roxygen2)
library(testthat)
devtools::session_info()
blogdown:::serve_site()
# Example
A <- c(1,2,3)
B <- c(1,0,0,0, 0, 1,0,0)
# print(convolution(A, B))
zapsmall(convolve(A, B, type = "open"))
a = c(1,2,3)
b= c(100)
convolve(a,b)
b= c(1,0,0)
convolve(a,b)
b= c(1,1)
convolve(a,b)
convolve(a,b,type = 'open')
?convolve
convolve(a,b,type = 'open')
convolve(c(1,2), c(1,1),type = 'open')
convolve(c(2,5), c(1,5),type = 'open')
convolve(c(2,5), c(2,5),type = 'open')
convolve(c(25), c(15),type = 'open')
convolve(c(25), c(25),type = 'open')
convolution(A, B)
# Example
A <- c(1,2,3)
B <- c(1,0,0,0, 0, 1,0,0)
# print(convolution(A, B))
zapsmall(convolve(A, B, type = "open"))
A
B
convolve(A, B, type = "open")
# print(convolution(A, B))
zapsmall(convolve(A, B, type = "open"))
zapsmall(convolve(B, A, type = "open"))
#----------------------------------------------------------------------#
# convolution
#----------------------------------------------------------------------#
convolution <- function(A, B) {
# Computes the convolution of two vectors.
#
# Args:
#   A, B: column vectors representing polynomial coefficients.
#
# Returns:
#   The coefficient vector resulting from multiplying the polynomial
#   represented by A by the polynomial represented by B.
Ap <- c(A, B*0)
Bp <- c(B, A*0)
C <- fft(Ap) * fft(Bp)
D <- round(fft(C, inverse=T))
E <- as.numeric(D)
R <- E/(length(A)+length(B))
return(R)
}
print(convolution(A, B))
convolve
# print(convolution(A, B))
zapsmall(convolve(A, B, type = "filter"))
# Example
A <- c(1,2,3)
B <- c(1,0,0,0, 0, 1,0,0)
# print(convolution(A, B))
zapsmall(convolve(A, B, type = "filter"))
convolve(A, B, type = "filter")
convolve(A, B, type = "open")
# print(convolution(A, B))
zapsmall(convolve(A, B, type = "open"))
zapsmall(convolve(B, A, type = "open"))
#======================================================================#
# simpple convolution
#======================================================================#
simple_conv <- function(A, B) {
# Computes the convolution of two vectors.
#
# Args:
#   A, B: column vectors representing polynomial coefficients.
#
# Returns:
#   The coefficient vector resulting from multiplying the polynomial
#   represented by A by the polynomial represented by B.
Ap <- c(A, B*0)
Bp <- c(B, A*0)
C <- fft(Ap) * fft(Bp)
D <- round(fft(C, inverse=T))
E <- as.numeric(D)
R <- E/(length(A)+length(B))
return(R)
}
# print(convolution(A, B))
simple_conv(A, B)
simple_conv(B, A)
#======================================================================#
#
#======================================================================#
convolution <- function (x, y, conj = TRUE, type = c("circular", "open", "filter")){
type <- match.arg(type)
n <- length(x)
ny <- length(y)
Real <- is.numeric(x) && is.numeric(y)
if (type == "circular") {
if (ny != n)
stop("length mismatch in convolution")
}
else {
n1 <- ny - 1
x <- c(rep.int(0, n1), x)
n <- length(y <- c(y, rep.int(0, n - 1)))
}
x <- fft(fft(x) * (if (conj)
Conj(fft(y))
else fft(y)), inverse = TRUE)
if (type == "filter")
(if (Real)
Re(x)
else x)[-c(1L:n1, (n - n1 + 1L):n)]/n
else (if (Real)
Re(x)
else x)/n
}
# print(convolution(A, B))
zapsmall(convolution(A, B, type = "open"))
(convolution(A, B, type = "open"))
# print(convolution(A, B))
zapsmall(convolution(A, B, type = "open"))
zapsmall(convolution(B, A, type = "open"))
#======================================================================#
#
#======================================================================#
convolution <- function (x, y, conj = TRUE, type = c("circular", "open", "filter")){
type <- match.arg(type)
n <- length(x)
ny <- length(y)
Real <- is.numeric(x) && is.numeric(y)
if (type == "circular") {
if (ny != n)
stop("length mismatch in convolution")
}
else {
n1 <- ny - 1
x <- c(x, rep.int(0, n1))
n <- length(y <- c(y, rep.int(0, n - 1)))
}
x <- fft(fft(x) * (if (conj)
Conj(fft(y))
else fft(y)), inverse = TRUE)
if (type == "filter")
(if (Real)
Re(x)
else x)[-c(1L:n1, (n - n1 + 1L):n)]/n
else (if (Real)
Re(x)
else x)/n
}
A <- c(1,2,3)
B <- c(1,0,0,0, 0, 1,0,0)
# print(convolution(A, B))
zapsmall(convolution(A, B, type = "open"))
zapsmall(convolution(B, A, type = "open"))
#======================================================================#
#
#======================================================================#
convolution <- function (x, y, conj = TRUE, type = c("circular", "open", "filter")){
type <- match.arg(type)
nx <- length(x)
ny <- length(y)
Real <- is.numeric(x) && is.numeric(y)
if (type == "circular") {
if (ny != nx)
stop("length mismatch in convolution")
}
else {
# n1 <- ny - 1
x <- c(x, rep.int(0, ny))
y <- c(y, rep.int(0, nx))
# n <- length(y <- c(y, rep.int(0, n - 1)))
}
x <- fft(fft(x) * (if (conj)
Conj(fft(y))
else fft(y)), inverse = TRUE)
if (type == "filter")
(if (Real)
Re(x)
else x)[-c(1L:ny, (nx - ny + 1L):nx)]/nx
else (if (Real)
Re(x)
else x)/nx
}
A <- c(1,2,3)
B <- c(1,0,0,0, 0, 1,0,0)
# print(convolution(A, B))
zapsmall(convolution(A, B, type = "open"))
zapsmall(convolution(B, A, type = "open"))
#======================================================================#
#
#======================================================================#
convolution <- function (x, y, conj = TRUE, type = c("circular", "open", "filter")){
type <- match.arg(type)
n <- length(x)
ny <- length(y)
Real <- is.numeric(x) && is.numeric(y)
if (type == "circular") {
if (ny != n)
stop("length mismatch in convolution")
}
else {
n1 <- ny - 1
x <- c(rep.int(0, n1), x)
n <- length(y <- c(y, rep.int(0, n - 1)))
}
x <- fft(fft(x) * (if (conj)
Conj(fft(y))
else fft(y)), inverse = TRUE)
if (type == "filter")
(if (Real)
Re(x)
else x)[-c(1L:n1, (n - n1 + 1L):n)]/n
else (if (Real)
Re(x)
else x)/n
}
A <- c(1,2,3)
B <- c(1,0,0,0, 0, 1,0,0)
# print(convolution(A, B))
zapsmall(convolution(A, rev(B), type = "open"))
zapsmall(convolution(B, rev(A), type = "open"))
# print(convolution(A, B))
zapsmall(convolution(A, rev(B), type = "open"))
zapsmall(convolution(B, rev(A), type = "open"))
#======================================================================#
#
#======================================================================#
myconvolve<-function (x,h){
nx <- length(x)
nh <- length(h)
#zero pad
if(nx>nh)
{
x <- c(x,rep(0, nh-1))
h<-c(h,rep(0,nx-1))
}
else
{
h <- c(h,rep(0, nx-1))
x<-c(x,rep(0,nh-1))
}
x <- fft(fft(x) * fft(h), inv = TRUE)
Re(x)/length(x)
#I am not sure about this, the R IFFT is weird
}
myconvolve(A, B)
myconvolve(B, A)
zapsmall(myconvolve(A, B))
zapsmall(myconvolve(B, A))
round(myconvolve(A, B))
zapsmall(myconvolve(A, B))
zapsmall(myconvolve(B, A))
?zapsmall
getOption("digits")
# print(convolution(A, B))
simple_conv(A, B)
simple_conv(B, A)
#======================================================================#
#
#======================================================================#
myconvolve<-function (x,h){
nx <- length(x)
nh <- length(h)
#zero pad
x <- c(x, rep(0, nh-1))
h <- c(h, rep(0, nx-1))
# if(nx > nh){
#   x <- c(x, rep(0, nh-1))
#   h <- c(h, rep(0, nx-1))
# }
# else{
#   h <- c(h,rep(0, nx-1))
#   x <- c(x,rep(0,nh-1))
# }
x <- fft(fft(x) * fft(h), inverse = TRUE)
Re(x)/length(x)
}
zapsmall(myconvolve(A, B))
zapsmall(myconvolve(B, A))
A
B
zapsmall(myconvolve(A, B))
zapsmall(myconvolve(B, A))
#======================================================================#
# circular convolution
#======================================================================#
myconvolve2 <- function (x,h){
#no padding, circular convolution
nx <- length(x)
nh <- length(h)
x <- fft(fft(x) * fft(h), inv = TRUE)
Re(x)/(nx)
}
zapsmall(myconvolve2(A, B))
zapsmall(myconvolve2(B, B))
A
B
A = c(1,2,3)
B = c(1,2,1)
zapsmall(myconvolve2(A, B))
zapsmall(myconvolve2(B, A))
A = c(1,2,3)
B = c(1,1,1)
zapsmall(myconvolve2(A, B))
zapsmall(myconvolve2(B, A))
#======================================================================#
# cross correlation
#======================================================================#
crosscorrelate <- function(x, h){
nx <- length(x)
nh <- length(h)
#zero pad
x <- c(x, rep(0, nh-1))
h <- c(h, rep(0, nx-1))
x <- fft(fft(x) * Conj(fft(h)), inverse = TRUE)
Re(x)/length(x)
}
A
B
zapsmall(crosscorrelate(A, B))
zapsmall(crosscorrelate(B, A))
A = c(1,2,3)
B  = c(1,2,3, 0, 0, 1,2,3)
zapsmall(crosscorrelate(A, B))
zapsmall(crosscorrelate(B, A))
#----------------------------------------------------------------------#
# kernel series (convolution kernel)
#----------------------------------------------------------------------#
par(mfrow=c(1,1))
kernel_series <- c(0, 1, 2, 3)
# plot kernel series
zero_head <- rep(0, 3)
zero_tail <- rep(0, 3)
kernel_series_paded <- c(zero_head, kernel_series, 0, zero_tail)
t_kernel <- c(1:length(zero_head),
(1:length(kernel_series)) + length(zero_head),
length(c(zero_head, kernel_series)),
(1:length(zero_tail)) + length(c(zero_head, kernel_series)) + 1
) - (length(zero_head) + 1)
plot(t_kernel, kernel_series_paded, type = 'l', lwd=3, col= 'steelblue')
#----------------------------------------------------------------------#
# delta series
#----------------------------------------------------------------------#
delta_series <- rep(c(1, rep(0, 5)), 3)
# plot delta function series
x0 <- which(delta_series %in% 1)
y0 <- rep(0, length(x0))
x1 <- x0
y1 <- rep(1, length(x1))
plot(x1, y1, xlim = c(min(x1) - 3, max(x1) + 3), main = "delta series")
arrows(x0, y0, x1, y1, length=0.1, angle=40, lwd=3, col= 'steelblue')
#----------------------------------------------------------------------#
# convolution
#----------------------------------------------------------------------#
conv_result <- convolve(delta_series, rev(kernel_series), type = 'open')
zapsmall(conv_result)
# plot convolved results
plot(1:length(conv_result), conv_result, type = 'l', lwd=3, col= 'steelblue')
#----------------------------------------------------------------------#
# overview
#----------------------------------------------------------------------#
par(mfrow=c(3,1))
plot_type <- 'p'
plot(t_kernel, kernel_series_paded, type = plot_type, lwd=3, col= 'steelblue', xlim=c(-2,20))
plot(x1, y1, xlim=c(-2, 20), main = "delta series")
arrows(x0, y0, x1, y1, length=0.0, angle=40, lwd=3, col= 'steelblue')
plot(1:length(conv_result), conv_result, type = plot_type, lwd=3, col= 'steelblue', xlim=c(-2,20))
f1u <- function(x) {ifelse ((abs(x) >  3 & abs(x) <= 7), 3*sqrt(1-(x/7)^2), 0)}
f1d <- function(x) {ifelse ((abs(x) >= 4 & abs(x) <= 7), -3*sqrt(1-(x/7)^2), 0)}
f2u <- function(x) {ifelse ((abs(x) > 0.50 & abs(x) < 0.75),  3*abs(x)+0.75, 0)}
f2d <- function(x) {ifelse ((abs(x) > -4 & abs(x) < 4), abs(x/2)-(3*sqrt(33)-7)*x^2/112-3 + sqrt(1-(abs(abs(x)-2)-1)^2), 0)}
f3u <- function(x) {ifelse ((x > -0.5 & x < 0.5), 2.25, 0)}
f4u <- function(x) {ifelse ((abs(x) >  1 & abs(x) <= 3), 6 * sqrt(10)/7 + (1.5 - 0.5 * abs(x)) * sqrt(abs(abs(x)-1)/(abs(x)-1)) - 6 * sqrt(10) * sqrt(4-(abs(x)-1)^2)/14, 0)}
f5u <- function(x) {ifelse ((abs(x) >= 0.75 & abs(x) <= 1), 9-8*abs(x), 0)}
fu <- function (x) f1u(x)+f2u(x)+f3u(x)+f4u(x)+f5u(x)
fd <- function (x) f1d(x)+f2d(x)
batman <- function(r,x) {ifelse(r%%2==0, fu(x), fd(x))}
batman
data.frame(x=seq(from=-7, to=7, by=0.125)) %>%
mutate(y=batman(row_number(), x)) -> df
# install.packages('devtools')
# require(devtools)
# install_github('rCharts', 'ramnathv')
# install.packages("tidyverse")
# install.packages('tm')
library('tidyverse')
data.frame(x=seq(from=-7, to=7, by=0.125)) %>%
mutate(y=batman(row_number(), x)) -> df
batman <- function(r,x) {ifelse(r%%2==0, fu(x), fd(x))}
data.frame(x=seq(from=-7, to=7, by=0.125)) %>%
mutate(y=batman(row_number(), x)) -> df
df
df %>% ggplot(aes(x,y)) + geom_line()
df %>% ggplot(aes(x,y)) + +geom_points() + geom_line()
df %>% ggplot(aes(x,y)) + +geom_point() + geom_line()
df %>% ggplot(aes(x,y)) + geom_point() + geom_line()
blogdown:::new_post_addin()
2018 - 1687
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
servr::daemon_stop("4454501048")
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
1. Outline sentence 1:
2. Outline sentence 2:
3. Outline sentence 3:
4. Outline sentence 4:
5. Outline sentence 5:
6. Outline sentence 6:
7. Outline sentence 7:
8. Outline sentence 8:
9. Outline sentence 9:
10. Outline sentence 10 (repeat if necessary):
blogdown::serve_site()
blogdown::serve_site()
